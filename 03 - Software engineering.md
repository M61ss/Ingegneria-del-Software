# 03 - Software engineering <!-- omit from toc -->

- [Introduzione](#introduzione)
- [Fallimento dei progetti](#fallimento-dei-progetti)
- [Failures' causes](#failures-causes)
- [Coordinazione](#coordinazione)
- [Software engineer (definition)](#software-engineer-definition)
- [Code of ethics](#code-of-ethics)
  - [Riassumendo](#riassumendo)
  - [Principles of software engineering](#principles-of-software-engineering)
- [Software process](#software-process)
  - [Code and fix](#code-and-fix)
  - [Code and fix extended](#code-and-fix-extended)
  - [Waterfall model](#waterfall-model)
  - [Modello incrementale](#modello-incrementale)
  - [Considerazioni finali](#considerazioni-finali)

> [**Return to full index**](00%20-%20Index.md)

## Introduzione

L'ingegneria del software è necessaria per imporre delle linee guida per i programmatori per evitare che i progetti falliscano. Con questo scopo si studiano dei modelli, si analizzano fallimenti e successi del passato e si provano a realizzare dei miglioramenti.

Il fatto che ancora oggi alcuni progetti software falliscano indica che ci sono ancora problemi che non sono stati rilevati o comunque non studiati a fondo siccome vengono ripetuti.

## Fallimento dei progetti

Presi in esame 300 progetti di diverse dimensione nel 1995, è stato rilevato che soltanto il 16% è stato completato in tempo e rientrando nel budget. Nel 2009 questo dato è salito al 32%.

![project_failures](resources\project_failures.png)

Alcune importanti ragioni di successo sono:

- Coinvolgimento dell'utente: ciò può avvenire per esempio fornendogli delle versioni non definitive del software, chiedendogli di verificare quindi che il sistema soddisfi correttamente quei requisiti che sono già stati implementati. Spesso capita che, siccome lo sviluppo richiede molto tempo, quando l'utente riceve il software definitivo esso abbia cambiato esigenze o non si ritrovi soddisfatto del sistema; quest'ultima situazione ha un'alta probabilità di verificarsi perché l'utente non è un esperto, dunque molto spesso non ha le idee chiare di ciò che vuole.
- Gestione esecutiva del supporto.
- Definizioni chiare dei requisiti.
- Pianificazione adeguata.

Le più note cause di fallimento sono:

- Mancanza dell'input dell'utente.
- Incompletezza dei requisiti e delle specifiche.
- Cambiamento dei requisiti e delle specifiche.

![project_failures_1](resources\project_failures_1.png)

## Failures' causes

![failures_causes](resources\failures_causes.png)

As we can see, more errors are generated by coding.

Gli errori introdotti durante la fase di raccolta dei requisiti possono propagarsi nel design e nella programmazione, con la possibilità di non essere scoperti fino al rilascio del software. Questo genere di errori è più costoso da risolvere rispetto a un errore nel codice.

Il problema principale sta nel fatto che i requisiti e il design non possono essere eseguiti subito; per ovviare a questo problema si potrebbe pensare di sviluppare un prototipo, ma non sempre è conveniente.

## Coordinazione

Siccome le ragioni di fallimento si allontanano dall'essere tecniche proporzionalmente all'aumento della complessità del software, per ridurre il rischio molte aziende comprano prodotti di grandi corporazioni già affermate nel settore, occupandosi di implementare o personalizzare il sistema acquistato.

Sono state identificate tre strategie chiave per assicurare la consegna di software di alta qualità, realizzato nei tempi prestabiliti ed entro il budget:

- Concentrare l'attenzione sull'ambiente di sviluppo (persone, strumenti, organizzazione, ecc.).
- "Disciplinare" il processo di sviluppo.
- Utilizzo metodico delle metriche per la misura dei costi, dell'organizzazione e degli obiettivi delle prestazioni funzionali.

![software_perspectives](resources\software_perspectives.png)

## Software engineer (definition)

_"L'ingegneria del software è una disciplina che concerne tutti gli aspetti della produzione del software, dalle prime fasi di specifica del sistema alla manutenzione di esso dopo che è entrato in uso."_

L'ingegnere del software è una figura che tocca tutti gli aspetti di sviluppo e supporto di un software, estendendosi alle seguenti aree chiave:

- Processo tecnico e business.
- Metodologie e tecniche specifiche.
- Caratterizzazione del prodotto e misurazione delle metriche.
- Abilità del personale e lavoro del team.
- Strumenti e formazione.
- Coordinazione del progetto e gestione.

## Code of ethics

Ci sono 8 principi da rispettare per un ingegnere del software:

1. Public: gli ingegneri del software devono agire nel pubblico interesse.
2. Client and employer: gli ingegneri del software devono agire nel miglior modo nell'interesse del loro cliente e datore di lavoro consistente nel pubblico interesse.
3. Product: gli ingegneri del software devono assicurare che i loro prodotti e le relative modifiche incontrino i più alti standard professionali possibili.
4. Judgment: gli ingegneri del software devono mantenere integrità e indipendenza nel loro giuizio professionale.
5. Management: gli ingegneri del software e i leaders devono sottostare a e promuovere un approccio etico alla gestione dello sviluppo e della manutenzione del software.
6. Profession: gli ingegneri del software devono mettere in primo piano l'integrità e la reputazione della professione nel pubblico interesse.
7. Colleagues: gli ingegneri del software devono essere onesti e di supporto nei confronti dei colleghi.
8. Self: gli ingegneri del software devono partcipare per tutta la vita all'apprendimento rigaurdo la pratica della loro professione e devono promuoverne un approccio etico.

### Riassumendo

Gli ingegneri del software devono:

- Rispettare gli altri.
- Impegnarsi per l'equità.
- Fare del loro meglio secondo le loro capacità.
- Seguire la legge.
- Gestire la riservatezza delle informazioni, i problemi di qualità e le loro soluzioni, la stime relative i progetti e la loro coordinazione, il riutilizzo, la proprietà intellettuale e la sicurezza.

### Principles of software engineering

![davis](resources\davis.png)
![davis_1](resources\davis_1.png)

---

![walker](resources\walker.png)

---

![wasserman](resources\wasserman.png)

Il **debito tecnico** è un effetto collaterale della necessità di rilasciare troppo rapidamente: i programmatori si trovano a comporre il sistema in modo rapido, quindi nella pratica potremmo visualizzare questi problemi in documentazione carente, eccessiva complessità dell'implementazione, ecc.. Questo effetto collaterale viene detto "debito" perché in futuro costerà caro a chi dovrà modificare il software.

## Software process

I **software process models** sono utili per evitare i gli ingegneri del software basino le loro scelte solo sulla loro esperienza passata. Questi modelli sono utili per fornire una guida nel coordinare e controllare i compiti da svolgere per raggiungere il prodotto finale e gli obiettivi del progetto.
\
Con questo scopo si definiscono:

- Un insieme di task che devono essere svolte.
- L'input e l'output di ognuna di esse.
- Le condizioni iniziali e il risultato finale di ogni task.
- La sequenza e il flusso di ognuna di esse.

Per progetti che coinvolgono più persone sono stati definiti processi che forniscono i seguenti benefici:

- Miglior comprensione delle task da eseguire dai membri del team.
- Responsabilità, aspettative e risultati meglio definiti dai membri del team di progetto.
- Misuramento e controllo del progresso del progetto facilitati.

### Code and fix

![code_and_fix](resources\code_and_fix.png)

In questo caso il modello è molto semplice: vengono raccolti dei requisiti (problem statement) e lo unit testing viene eseguito in modo informale da colui che scrive il codice.

### Code and fix extended

Siccome i progetti sono diventati più grandi, si sono presentate una serie di necessità:

- Chiarire e stabilire i requisiti.
- Testare più funzionalità.
- Effettuare il design con più cautela.
- Usare più software esistente, come ad esempio databases, networks, code contols, ecc..
- Includere più persone.

### Waterfall model

![waterfall](resources\waterfall.png)

Le task si susseguono l'una dopo l'altra: l'output dell'una sarà l'input della successiva. Questo modello consente al project manager di descrivere lo stato del progetto, potendo visualizzare il ciclo di vita del progetto in base allo stadio i cui il software si trova.

Aspetti positivi:
- I requisiti devono essere definiti per primi.
- Devono essere completate quattro tasks priima che il sistema possa essere rilasciato.
- L'output di ogni stadio viene assegnato come input per quello successivo.
- Il progetto può essere tracciato e si muove sequenzialmente attraverso tasks identificabili.

Sono state proposte modifiche del modello, come ad esempio frecce che consentano di retrocedere, introducendo quindi l'iterabilità di alcune fasi del modello.

Il modello waterfall ha un grande problema: bassa interazione con l'utente.

### Modello incrementale

Può essere visto come una modifica del modello waterfall. I grandi progetti possono essere semplificati suddividendoli in componenti più piccoli. Essi possono essere sviluppati incrementalmente e iterativamente. Al termine del processo i componenti sono integrati e testati come un unico sistema nel test finale del software.

Questo modello implementa una sorta di contenimento del rischio perché se qualche componente ha un problema, gli altri sono in grado di essere sviluppati indipendentemente. 

Il modello incrementale consente di sviluppare prima i componenti più importanti e rilasciare in futuro le funzionalità addizionali.

#### Modello incrementale mulitple-component <!-- omit from toc -->

![multiple-component_incremental](resources\multiple-component_incremental.png)

#### Modello incrementale multiple-release <!-- omit from toc -->

![multiple-release_incremental](resources\multiple-release_incremental.png)

### Considerazioni finali

Entrambi i modelli, waterfall e incrementale, implementano la tecnica "divide and conquer".
\
Tipicamente i problemi sono intrecciati, rendendo difficile la scomposizione in parti indipendenti; ciò richiede una comprensione profonda del problema, della soluzione e dell'ambiente di utilizzo.

Il modello multiple-release è la rappresentazione di un precursore della nozione odierna di integrazione continua e rilascio continuo (CI/CD), modelli chiave per garantire la rapida ed efficacie distribuzione del software. Chiaramente, è necessario un buon strumento di build e integrazione per applicare agevolemente il modello CI/CD.
